<!DOCTYPE html>
<html ng-app="jcs-demo">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="http://prismjs.com/themes/prism.css" />
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,200' rel='stylesheet' type='text/css'>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Angular-auto-validate by jonsamwell</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Angular-auto-validate</h1>
        <h2>An automatic validation module for AngularJS which gets rid of excess html in favour of dynamic element modification to notify the user of validation errors</h2>
        <a href="https://github.com/jonsamwell/angular-auto-validate" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
            <h3 id="demo">Demo.</h3>
            <p>The below demo shows the functionality of this module.  Start typing into the inout boxes to see the validation.</p>

            <div ng-controller="demoCtrl">
            <p>
                <button type="button" class="btn btn-primary" ng-click="toggleBS3Icons();">Toggle Validation State Icons</button>
            </p>
            <form role="form" novalidate="novalidate" ng-submit="submit()">
                <div class="form-group">
                    <label class="control-label">Name</label>
                    <input type="text"
                           class="form-control"
                           placeholder="Enter Name"
                           ng-model="user.name"
                           required="required" />
                </div>
                <div class="form-group">
                    <label class="control-label">Email address - <small>Element with a custom element modifier (see source code)</small></label>
                    <input type="email"
                           class="form-control"
                           placeholder="Enter email"
                           ng-model="user.email"
                           required="required"
                           element-modifier="myCustomModifierKey">
                </div>
                <div class="form-group">
                    <label class="control-label">Password - <small>Element with validation happening on blur rather than change</small></label>
                    <input type="password" class="form-control"
                           ng-model="user.password"
                           placeholder="Password"
                           required="required"
                           ng-minlength="6"
                           ng-model-options="{updateOn: 'blur'}">
                </div>
                <div class="form-group">
                    <label class="control-label">Robot Test: Please spell Angular. - <small>Custom validation</small></label>
                    <input type="text"
                           class="form-control"
                           placeholder="Enter The Word Angular"
                           ng-model="user.iq"
                           mustcontainword="angular"/>
                </div>

                <button type="submit" class="btn btn-default">Submit</button>
            </form>
        </div>

          <h3 id="getting_started">Getting Started.</h3>
            <div class="callout">
                <p>For the best overview of the module and module architecture see my <a href="http://jonsamwell.com/dynamic-angularjs-validation/">original blog post here</a>.</p>
            </div>

            <p>Install and manage AngularStrap with <a href="http://bower.io">Bower</a>.</p>
            <pre><code class="language-javascript">$ bower install angular-auto-validate --save</code></pre>

            <p>Load the required javascript libraries</p>
            <pre><code class="language-markup">&lt;script src="bower_components/angular-auto-validate/dist/jcs-auto-validate.min.js"&gt;&lt;/script&gt;</code></pre>

            <p>Inject the jcs-auto-validate into your application</p>
            <pre><code class="language-javascript">angular.module('my-app', ['jcs-autoValidate']);</code></pre>

            <p>If you are using bootstrap 3 that's it, unless you wish the valid and invalid states of your controls to be
                indicated via icons, otherwise auto-validate is setup!
            <pre><code class="language-javascript">angular.module('my-app')
        .run([
        'bootstrap3ElementModifier',
        function (bootstrap3ElementModifier) {
              bootstrap3ElementModifier.enableValidationStateIcons(true);
       }]);</code></pre>

            <p>if you are using Foundation 5 you will need to set the Foundation 5 element modifier as the default one</p>
            <pre><code class="language-javascript">angular.module('my-app')
       .run([
       'validator',
       'foundation5ElementModifier',
       function (validator, foundation5ElementModifier) {
           validator.setDefaultElementModifier(foundation5ElementModifier.key);
       }]);</code></pre>

            <p>If you are not using Bootstrap3 or Foundation5 you will need to create a custom element modifier so <a href="custom_dom_modifiers">see the below section</a></p>

            <h3 id="your_form">Your Form</h3>
            <p>Now that you are using auto-validate you haven't got to worry about putting your error messages in you html
            or using any angular expressions to show or hide them depending on the validation state.  So now your form markup remains
            clean and maintainable</p>
<pre><code class="language-markup">&lt;form name=&quot;signupFrm&quot; novalidate=&quot;novalidate&quot;&gt;
    &lt;div classs=&quot;form-row&quot;&gt;
        &lt;label&gt;Username:&lt;/label&gt;
        &lt;input name=&quot;username&quot;
            ng-model=&quot;model.username&quot;
            ng-minlength=&quot;3&quot;
            ng-maxlength=&quot;10&quot;
            required/&gt;
    &lt;/div&gt;
    &lt;div classs=&quot;form-row&quot;&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input name=&quot;password&quot;
            type=&quot;password&quot;
            ng-model=&quot;model.password&quot;
            ng-minlength=&quot;3&quot;
            ng-maxlength=&quot;10&quot;
            required/&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre>

            <h3 id="ngmodeloptions">NgModelOptions Support</h3>
            <p>
                By default AngularJS triggers validation on change, while this is great for illustrating the power of Angular
                it can be somewhat annoying to the user if they are typing their name in and after the first letter it tells
                them their name must be more than 3 characters. Now Angular 1.3+ has the support for ngModelOptions which
                lets us specify when Angular should update the bound model and fire the validation process. We can
                now easily specify it should be on blur rather than on change. However, those of us who need to support
                older browsers (IE8) cannot use this newer version as it does not officially support them. So, I have
                added very rudimentary support for the updateOn option of ngModelOptions even for Angular 1.2 and below!
                Simply add the ngModelOption directive as usual and you can easily change the trigger event of the element.
            </p>

            <pre><code class="language-markup">
&lt;input type="text"
       ng-model="model.name"
       ng-model-options="{updateOn: 'blur'}"
       required
       ng-minlength="5" /&gt;
            </code></pre>

            <h3 id="ngsubmit">ngSubmit</h3>
            <p>The typical way to test if a form is valid before submitting is to pass the form into the ngSubmit method
            you define on your scope.  This isn't ideal as you are passing in a psuedo UI element into your controller.  I would prefer
            that the ngSubmit function you defined is simply not called if the form is invalid.  Luckily, this is exactly what happens
            in auto-validate.  When the user clicks on the submit button the form is validated and the child UI elements have their
            validation states applied so the user can see what is valid/invalid.  Only if the whole form is valid will the ngSubmit method
            be called.  Of course, it you would prefer it is called even if the form is invalid you can use the ngSubmitForce attribute shown below.</p>
<pre><code class="language-markup">&lt;form name=&quot;signupFrm&quot; novalidate=&quot;novalidate&quot; ng-submit=&quot;submit();&quot; ng-submit-force=&quot;true&quot;&gt;
    &lt;div classs=&quot;form-row&quot;&gt;
    &lt;label&gt;Username:&lt;/label&gt;
    &lt;input name=&quot;username&quot;
        ng-model=&quot;model.username&quot;
        ng-minlength=&quot;3&quot;
        ng-maxlength=&quot;10&quot;
        required/&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-row&quot;&gt;
    &lt;label&gt;Password:&lt;/label&gt;
    &lt;input name=&quot;password&quot;
        type=&quot;password&quot;
        ng-model=&quot;model.username&quot;
        ng-minlength=&quot;3&quot;
        ng-maxlength=&quot;10&quot;
        required/&gt;
    &lt;/div&gt;
    &lt;/form&gt;
</code></pre>

            <h4>Changing Element States</h4>
            <p>If you want a certain element to appear differently to other elemenets when it is valid/invalid you can still do that by just specifying which element modifier
                should be used to modifier the elements visual state. This can be achieve by using the attribute <code>element-modifier="elementModifierKey"</code>.</p>
<pre><code class="language-markup">&lt;!-- auto-validate will use the default element modifier --&gt;
&lt;input type=&quot;text&quot;
    ng-model=&quot;model.firstname&quot;
    required
    ng-minlength=&quot;2&quot; /&gt;

&lt;!-- auto-validate will try to find a custom modifier with the key 'myCustomModifier' --&gt;
&lt;input type=&quot;text&quot;
    ng-model=&quot;model.middlename&quot;
    required
    ng-minlength=&quot;2&quot;
    element-modifier=&quot;myCustomModifier&quot; /&gt;

&lt;!-- auto-validate will try to find a custom modifier with the key 'myOtherCustomModifier' --&gt;
&lt;input type=&quot;text&quot;
    ng-model=&quot;model.surname&quot;
    required
    ng-minlength=&quot;2&quot;
    element-modifier=&quot;myOtherCustomModifier&quot; /&gt;
</code></pre>

            <h3 id="error_message_resolver">Error Message Resolver</h3>
            <p>An error message resolver is an object that turns a validation error type (required, minlength etc) into an actual validation message
                that can be displayed to the user to help them rectify the validation error.  By default auto-validate has one built in that contains
            English error messages for all the default angular validation types.  However if you have custom validation filters you will need to add them
            to the default error message resolver in order to provide a custom error message when that validation type if triggered.</p>

            <pre><code class="language-javascript">angular.module('jcs-autoValidate')
    .run([
    'defaultErrorMessageResolver',
    function (defaultErrorMessageResolver) {
        // passing a culture into getErrorMessages('fr-fr') will get the culture specific messages
        // otherwise the current default culture is returned.
        defaultErrorMessageResolver.getErrorMessages().then(function (errorMessages) {
          errorMessages['myCustomError'] = 'My custom error message';
          errorMessages['anotherErrorMessage'] = 'An error message with the attribute value {0}';
        });
    }
]);
            </code></pre>

            <h3 id="i18n">i18n</h3>
            The default error message resolver that is enabled out of the box now has i18n support!  While this is fairly basic support
            it gives enough to not have to implement a custom error message resolver to do complex translations.  The default culture is
            'en-GB' which is basically 'en-US'.

            <h5>Setting a Culture</h5>
            The default culture for error messages is 'en-GB' this can be changed by simply setting the correct culture on the defaultErrorMessageResolver.
            This will automatically go off and fetch the correct culture resource file from the server.  By default the library will request the file from
            '{js/angular-auto-validate/dist/lang}/jcs-auto-validate_##-##.json'.  However, if the culture files are in a different location you can set the
            root path for the culture files (the part of the above url in brackets {js/angular-auto-validate/dist/lang}) by calling <code>setI18nFileRootPath('some/path)</code>


            <pre><code class="language-javascript">angular.module('jcs-autoValidate')
.run([
    'defaultErrorMessageResolver',
    function (defaultErrorMessageResolver) {
        // To change the root resource file path
        //defaultErrorMessageResolver.setI18nFileRootPath('some/path);
        defaultErrorMessageResolver.setCulture('fr-FR');
    }
]);
            </code></pre>

            Alternatively, you can provide your own loading function to the setCulture method that should return a promise and resolve that promise with the object
            structure expected in a resource file.

            <pre><code class="language-javascript">angular.module('jcs-autoValidate')
.run([
    '$q',
    'defaultErrorMessageResolver',
    function ($q, defaultErrorMessageResolver) {

        defaultErrorMessageResolver.setCulture('fr-FR', function () {
            var defer = $q.defer();

            // you can get the error messages however you want and resolve the promise when they are loaded
            // defer.resolve(errorMessagesRetreivedBySomeMethod);
            return defer.promise;
        });
    }
]);
            </code></pre>


            <h5>Small Caveat</h5>
            <p>While I might know lots of programming languages I do not know many (well only one) actual language.  So at the moment we only have English
                and French translations. If you can translate the default 'angular-auto-validate_en-GB.json' into any other language that would be great!  PR the repo
                or email me it as that would be awesome!</p>

            <br/>

            <h4 id="custom_error_resolver">Custom Error Message Resolver</h4>
            <p>If you need more fined grained control over how a validation error type is converted into an error message you may wish to create a
            custom error message resolver.  This is really simple and you can do anything you like to resolve an error type into a error message.  You might
            for instance need to provide a custom translation into the user's language or go to the server etc.</p>

<pre><code class="language-javascript">
angular.module('my-app')
    .factory('myCustomErrorMessageResolver', [
    '$q',
    function ($q) {
        /**
        * @ngdoc function
        * @name defaultErrorMessageResolver#resolve
        * @methodOf defaultErrorMessageResolver
        *
        * @description
        * Resolves a validate error type into a user validation error message
        *
        * @param {String} errorType - The type of validation error that has occurred.
        * @param {Element} el - The input element that is the source of the validation error.
        * @returns {Promise} A promise that is resolved when the validation message has been produced.
        */
        var resolve = function (errorType, el) {
            var defer = $q.defer();
            // do something to get the error message
            // then resolve the promise defer.resolve('some error message');
            return defer.promise;
        };

        return {
            resolve: resolve
        };
    }
]);

// now set the custom error resolver as the module's default one.
angular.module('my-app')
    .run([
    'validator',
    'myCustomErrorMessageResolver',
    function (validator, myCustomErrorMessageResolver) {
        validator.setDefaultErrorMessageResolver(myCustomErrorMessageResolver);
    }
]);
</code></pre>

            <h3 id="custom_dom_modifiers">Custom Element Modifier</h3>

            <p>If you are not using Bootstrap3 or Foundation5 CSS libraries you will need to create a custom element modifier
                which takes care of updating the visual state of an element, don't worry this is really easy! You can see a few example
            of what to put in them <a href="" target="_blank">here</a> and <a href="" target="_blank">here</a>.</p>
<pre><code class="language-javascript">angular.module('my-app')
    .factory('myCustomElementModifier', [
        function () {
            var /**
            * @ngdoc function
            * @name myCustomElementModifier#makeValid
            * @methodOf myCustomElementModifier
            *
            * @description
            * Makes an element appear valid by apply custom styles and child elements.
            *
            * @param {Element} el - The input control element that is the target of the validation.
            */
            makeValid = function (el) {
            // do some code here...
            },

            /**
            * @ngdoc function
            * @name myCustomElementModifier#makeInvalid
            * @methodOf myCustomElementModifier
            *
            * @description
            * Makes an element appear invalid by apply custom styles and child elements.
            *
            * @param {Element} el - The input control element that is the target of the validation.
            * @param {String} errorMsg - The validation error message to display to the user.
            */
            makeInvalid = function (el, errorMsg) {
            // do some code here...
            };

            return {
                makeValid: makeValid,
                makeInvalid: makeInvalid,
                key: 'myCustomModifierKey'
            };
        }
    ]);

// now register the custom element modifier with the auto-validate module and set it as the default one for all elements
angular.module('my-app')
    .run([
    'validator',
    'myCustomElementModifier',
    function (validator, myCustomElementModifier) {
        validator.registerDomModifier(myCustomElementModifier.key, myCustomElementModifier);
        validator.setDefaultElementModifier(myCustomElementModifier.key);
    }
]);

</code></pre>

<h3 id="author">
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Originally authored by <a href="http://www.jonsamwell.com" target="_blank">Jon Samwell</a>.</p>
<p>Contributions from <a href="https://github.com/DanielBodnar" target="_blank">@DanielBodnar</a> & <a href="https://github.com/jgoux" target="_blank">@jgoux</a></p>

<h3 id="issues">
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Add all issues and feature ideas to the <a href="https://github.com/jonsamwell/angular-auto-validate">github repo</a></p>
        </section>

        <aside id="sidebar">
            <h3>Menu</h3>
            <ul>
                <li><a href="#getting_started">Getting Started</a></li>
                <li><a href="#demo">Demo</a></li>
                <li><a href="#your_form">Your Form</a></li>
                <li><a href="#ngmodeloptions">NgModelOptions Support</a></li>
                <li><a href="#ngsubmit">ngSubmit</a></li>
                <li><a href="#error_message_resolver">Error Message Resolver</a></li>
                <li><a href="#i18n">i18n</a></li>
                <li><a href="#custom_dom_modifiers">Custom Dom Modifiers</a></li>
                <li><a href="#author">Author and Contributors</a></li>
                <li><a href="#issues">Issues and Feature Requests</a></li>
            </ul>
          <a href="https://github.com/jonsamwell/angular-auto-validate/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/jonsamwell/angular-auto-validate/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/jonsamwell/angular-auto-validate"></a> is maintained by <a href="https://github.com/jonsamwell">jonsamwell</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  <script type="text/javascript" src="http://prismjs.com/prism.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.16/angular.min.js"></script>
    <script src="javascripts/angular-auto-validate/dist/jcs-auto-validate.min.js"></script>
    <script type="text/javascript">
        (function (angular) {
            var app = angular.module('jcs-demo', ['jcs-autoValidate']);

            app.controller('demoCtrl', [
                '$scope',
                'bootstrap3ElementModifier',
                function ($scope, bootstrap3ElementModifier) {
                    $scope.user = {};
                    $scope.bs3Icons = false;

                    $scope.toggleBS3Icons = function () {
                        $scope.bs3Icons = !$scope.bs3Icons;
                        bootstrap3ElementModifier.enableValidationStateIcons($scope.bs3Icons);
                    }

                    $scope.toggleBS3Icons();

                    $scope.submit = function () {
                        alert('Form is valid and submitted');
                    }
                }
            ]);

            app.directive('mustcontainword', [
                function() {
                    return {
                        restrict: 'A',
                        require: 'ngModel',
                        link: function(scope, elm, attrs, ctrl) {
                            var validateFn = function (viewValue) {
                                if (ctrl.$isEmpty(viewValue) || viewValue.toLowerCase().indexOf(attrs.mustcontainword.toLowerCase()) === -1) {
                                    ctrl.$setValidity('mustcontainword', false);
                                    return undefined;
                                } else {
                                    ctrl.$setValidity('mustcontainword', true);
                                    return viewValue;
                                }
                            };

                            ctrl.$parsers.push(validateFn);
                            ctrl.$formatters.push(validateFn);
                        }
                    }
            }]);

            app.factory('myCustomElementModifier', [
                function () {
                    var /**
                             * @ngdoc function
                             * @name myCustomElementModifier#makeValid
                             * @methodOf myCustomElementModifier
                             *
                             * @description
                             * Makes an element appear valid by apply custom styles and child elements.
                             *
                             * @param {Element} el - The input control element that is the target of the validation.
                             */
                            makeValid = function (el) {
                                el.removeClass('bg-red');
                                el.addClass('bg-green');
                            },

                            /**
                             * @ngdoc function
                             * @name myCustomElementModifier#makeInvalid
                             * @methodOf myCustomElementModifier
                             *
                             * @description
                             * Makes an element appear invalid by apply custom styles and child elements.
                             *
                             * @param {Element} el - The input control element that is the target of the validation.
                             * @param {String} errorMsg - The validation error message to display to the user.
                             */
                            makeInvalid = function (el, errorMsg) {
                                el.removeClass('bg-green');
                                el.addClass('bg-red');
                            };

                    return {
                        makeValid: makeValid,
                        makeInvalid: makeInvalid,
                        key: 'myCustomModifierKey'
                    };
                }
            ]);

            // now register the custom element modifier with the auto-validate module and set it as the default one for all elements
            app.run([
                'validator',
                'myCustomElementModifier',
                 'defaultErrorMessageResolver',
                function (validator, myCustomElementModifier, defaultErrorMessageResolver) {
                    validator.registerDomModifier(myCustomElementModifier.key, myCustomElementModifier);
                    defaultErrorMessageResolver.getErrorMessages().then(function (errorMessages) {
                        errorMessages['mustcontainword'] = 'Please enter the word "{0}"';
                    });
                }
            ]);
        }(angular));
    </script>
  </body>
</html>
