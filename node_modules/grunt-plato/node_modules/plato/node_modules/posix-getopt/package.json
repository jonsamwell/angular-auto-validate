{
  "name": "posix-getopt",
  "version": "1.0.0",
  "description": "POSIX-style getopt()",
  "author": {
    "name": "Dave Pacheco",
    "url": "dap@cs.brown.edu"
  },
  "engines": {
    "node": "*"
  },
  "main": "./lib/getopt",
  "readme": "\nnode-getopt\n==============\n\nOverview\n--------\n\nnode-getopt implements the POSIX getopt() function for Node.  getopt() provides\na functional interface for option parsing.\n\nInstall the npm package in the usual way:\n\n\t$ npm install posix-getopt\n\nHere's how you'd typically use it for a command that takes options \"-a\" and\n\"-b\" with no arguments, option \"-o\" (also called \"--output\") with one argument,\nand another mandatory argument:\n\n\tvar mod_getopt = require('posix-getopt');\n\tvar parser, option;\n\n\tparser = new mod_getopt.BasicParser('abo:(output)', process.argv);\n\n\twhile ((option = parser.getopt()) !== undefined) {\n\t\tswitch (option.option) {\n\t\tcase 'a':\n\t\t\tconsole.log('option \"a\" is set');\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tconsole.log('option \"b\" is set');\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\tconsole.error('option \"o\" has value \"%s\"',\n\t\t\t    option.optarg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* error message already emitted by getopt */\n\t\t\tmod_assert.equal('?', option.option);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (parser.optind() >= process.argv.length)\n\t\tusage('missing required argument: \"input\"');\n\n\tconsole.log('input = %s', process.argv[parser.optind()]);\n\nExamples:\n\n\t$ cmd\n\terror: missing required argument: \"input\"\n\tusage: cmd [-ab] [-o file] input\n\n\t$ cmd foo\n\tinput = foo\n\n\t$ cmd -a foo\n\toption \"a\" is set\n\tinput = foo\n\n\t$ cmd -ba foo\n\toption \"b\" is set\n\toption \"a\" is set\n\tinput = foo\n\n\t$ cmd -ba -obar foo\n\toption \"b\" is set\n\toption \"a\" is set\n\toption \"o\" has value \"bar\"\n\tinput = foo\n\n\t$ cmd -ba --output=bar foo\n\toption \"b\" is set\n\toption \"a\" is set\n\toption \"o\" has value \"bar\"\n\tinput = foo\n\n\t$ cmd --output= foo\n\toption \"o\" has value \"\"\n\tinput = foo\n\n\t$ cmd -o \n\toption requires an argument -- o\n\terror: missing required argument: \"input\"\n\tusage: cmd [-ab] [-o file] input\n\n\t$ cmd -- -a\n\tinput = -a\n\n\t$ cmd -q\n\tillegal option -- q\n\terror: missing required argument: \"input\"\n\tusage: cmd [-ab] [-o file] input\n\n\nBackground\n--------\n\ngetopt() is a general-purpose command line parser that follows the POSIX\nguidelines for command-line utilities.  Using these guidelines encourages\ncommon conventions among applications, including use of:\n\n- short option names (e.g., \"-r\")\n- options with arguments (e.g., \"-f filename or -ffilename\")\n- chaining short option names when options have no arguments (e.g., \"-ra\")\n\nThis implementation mirrors the Solaris getopt() implementation and supports\nlong option names (e.g., \"--recurse\"), potentially with values specified using\n\"=\" (e.g., \"--file=/path/to/file\").\n\nUnlike other option parsers available for Node.js, the POSIX getopt() interface\nsupports using the same option multiple times (e.g., \"-vvv\", commonly used to\nindicate level of verbosity).\n\nFor further reference on the relevant POSIX standards, see the following:\n\n    http://pubs.opengroup.org/onlinepubs/009695399/functions/getopt.html\n    http://pubs.opengroup.org/onlinepubs/009695399/utilities/getopts.html\n\nThe Utility Syntax Guidelines are described here:\n\n    http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html\n\n\nStatus\n------\n\nThis module is considered complete except that there's minimal automated test\ncoverage.  There are no known bugs.\n\n\nAPI\n---\n\n### `new getopt.BasicParser(optstring, argv)`\n\nInstantiates a new object for parsing the specified arguments using the\nspecified option string.  This interface is closest to the traditional getopt()\nC function.  Callers first instantiate a BasicParser and then invoke the\ngetopt() method to iterate the options as they would in C.  (This interface\nallows the same option to be specified multiple times.)  The first two arguments\nin \"argv\" are ignored, since they generally denote the path to the node\nexecutable and the script being run, so options start with the third element.\n\nThe option string consists of an optional leading \":\" (see below) followed by a\nsequence of option-specifiers.  Each option-specifier consists of a single\ncharacter denoting the short option name, optionally followed by a colon if the\noption takes an argument and/or a sequence of strings in parentheses\nrepresenting long-option aliases for the option name.\n\nExample option strings:\n\n\t':r'            Command takes one option with no args: -r\n\t':ra'           Command takes two option with no args: -r and -a\n\t':raf:'         Command takes two option with no args: -r and -a\n\t                and a single option that takes an arg: -f\n\t':f:(file)'     Command takes a single option with an argument: -f\n\t                -f can also be specified as --file\n\nThe presence of a leading colon in the option string determines the behavior\nwhen an argument is not specified for an option which takes an argument.  See\ngetopt() below.  Additionally, if no colon is specified, then error messages are\nprinted to stderr when invalid options, options with missing arguments, or\noptions with unexpected arguments are encountered.\n\n\n### `parser.optind()`\n\nReturns the next argv-argument to be parsed.  When options are specified as\nseparate \"argv\" arguments, this value is incremented with each option parsed.\nWhen multiple options are specified in the same argv-argument, the returned\nvalue is unspecified.  This matches the variable \"OPTIND\" from the POSIX\nstandard, but is read-only.  (If you want to reset OPTIND, you must create a new\nBasicParser instance.)  This is most useful after parsing has finished to\nexamine the non-option arguments.\n\nThis value starts at \"2\" as described under \"Departures from POSIX\" below.\n\n\n### `parser.getopt()`\n\nReturns the next argument specified in \"argv\" (the object's constructor\nargument).  The returned value is either undefined or an object with at least\nthe following members:\n\n\toption\t\tsingle-character option name\n\nThe following members may also be present:\n\n\toptarg\t\targument value, if any\n\n\toptopt\t\toption character that caused the error, if any\n\n\terror\t\tif true, this object represents an error\n\nThis function scans \"argv\" starting at the current value of \"optind\" and returns\nan object describing the next argument based on the following cases:\n\n- If the end of command line arguments is reached, an undefined value is\n  returned.  The end of arguments is signified by a single '-' argument, a\n  single '--' argument, an argument that's neither an option nor a previous\n  option's argument, the end of argv, or an error.\n\n- If an unrecognized command line option is found (i.e. an option character\n  not defined in \"optstring\"), the returned object's \"option\" member\n  is just \"?\".  \"optopt\" is set to the unrecognized option letter.  \"error\"\n  is set to a true value.\n\n- If a known command line option is found and the option takes no arguments\n  then the returned object's \"option\" member is the option's short name\n  (i.e.  the single character specifier in \"optstring\").\n      \n- If a known command line option is found and that option takes an argument\n  and the argument is also found, then the returned object's \"option\"\n  member is the option's short name and the \"optarg\" member contains the\n  argument's value.\n\n- If a known command line option is found and that option takes an argument\n  but the argument is not found, then the returned object's \"option\" member\n  is \"?\" unless the first character of \"optstring\" was a colon, in which\n  case the \"option\" member is set to \":\".  Either way, the \"optopt\" member\n  is set to the option character that caused the error and \"error\" is set to\n  a true value.\n\n\nDepartures from POSIX\n--------\n\n- Global state in the C implementation (e.g., optind, optarg, and optopt) is\n  encapsulated in the BasicParser object.  optind is available as a method\n  call on the parser object.  optarg and optopt are returned directly by\n  getopt().\n\n- Rather than returning an integer or character, getopt() returns an object\n  with the \"option\" field corresponding to the processed option character\n  and possibly the additional \"optarg\" and \"optopt\" fields.  If an error\n  occurs on a particular option, \"error\" is also set.  If an error occurs on\n  no particular option or if the end of input is encountered, undefined is\n  returned.\n\n- Long option forms are supported as described above.  This introduces an\n  additional error case which is where an argument of the form\n  --option=value is encountered, where \"option\" does not take a value.\n\n- POSIX starts \"optind\" at 1, since argv[0] is generally the name of the\n  command and options start at argv[1].  This implementation starts \"optind\"\n  at 2, since argv[0] is generally the path to the node binary and argv[1]\n  is the path to the script, so options start with argv[2].\n\n\nExamples\n--------\n\n### Example 1: simple short options\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-a', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\t{ option: 'a' }\n\n\n### Example 2: invalid option specified\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-b', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\tillegal option -- b\n\t{ option: '?', optopt: 'b', error: true }\n\n\n### Example 3: long options\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('lar(recurse)',\n\t    ['node', 'script', '-l', '--recurse', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\t{ option: 'r' }\n\n\n### Example 4: options with arguments\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('f:lad:',\n\t    ['node', 'script', '-l', '-f', 'filename', '-dtype', 'stuff']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\t{ option: 'f', optarg: 'filename' }\n\t{ option: 'd', optarg: 'type' }\n\n\n### Example 5: options with missing arguments\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('f:la',\n\t    ['node', 'script', '-l', '-a', '-f']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\t{ option: 'a' }\n\toption requires an argument -- f\n\t{ option: '?', optopt: 'f', error: true }\n\n\n### Example 6: options specified multiple times\n\n\tvar mod_getopt = require('getopt')\n\tvar parser, option;\n\t\n\tparser = new mod_getopt.BasicParser('la',\n\t    ['node', 'script', '-l', '-a', '-l']);\n\twhile ((option = parser.getopt()) !== undefined && !option.error)\n\t\tconsole.error(option);\n\noutputs:\n\n\t{ option: 'l' }\n\t{ option: 'a' }\n\t{ option: 'l' }\n",
  "readmeFilename": "README.md",
  "_id": "posix-getopt@1.0.0",
  "_shasum": "42a90eca6119014c78bc4b9b70463d294db1aa87",
  "_from": "posix-getopt@~1.0.0",
  "_resolved": "https://registry.npmjs.org/posix-getopt/-/posix-getopt-1.0.0.tgz"
}
